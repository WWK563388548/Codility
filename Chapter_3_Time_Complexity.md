# Chapter 3 时间复杂度(Time Complexity)
<br>
&emsp;使用时间复杂度可以使我们轻易估计程序的运行时间。进行程序运行时间的精确计算是非常复杂的行为（一种劳动密集型的行为: 这取决于编译器与计算机处理器的型号）。因此，我们将不做精确计算，而是仅仅估算出一个相对的数值。
<br>
&emsp;复杂度可以被看作是一个程序能被执行的简单运算的最大次数。通常的操作是加减乘除以及复制操作等等。我们可能会许可执行一些操作和计算无数次。这些计算被称作是显性的。
<br>
&emsp;显性计算的次数取决于特定的数据。我们经常想去知道如果在特定的数据下表现性能。这些特定的方面通常是数据的大小，也可以是矩阵的大小或者是一些变量的值。
<br>

***
哪一个是显性操作(计算)?
```python
def dominant(n):
  result = 0
  for i in range(n):
    # 这个操作将执行n次
    result += 1
  return result
```
&emsp;for循环中的操作“result += 1”是显性的，它将被执行n次。复杂度被大O符号所描述：在这个例子中的复杂度为O(n)既线性复杂度。
<br>
&emsp;复杂度指定程序将执行运算的数量级。更具体的说，例如在O(n)中，程序可能执行c*n次操作，其中c是一个常数；然而不可能执行n^2次操作，因为这涉及到数据数量级的膨胀。在另一方面，当我们计算复杂度的时候会省略常数：例如不管循环是执行20*n次或者是1/5*n次，我们的复杂度仍然是O(n),即使程序运行的时间不同。当我们分析复杂度时，我们必须去寻找数据中特定的，最坏的例子，这个例子将话费很长时间去运行。

***
### 3.1 比较不同的时间复杂度
&emsp;让我们来比较一下不同的时间复杂度。
<br>
3.1.1 常数时间---O(1):
<br>
```python
def constant(n):
  result = n * n
  return result
```
&emsp;这里总是一个固定次数次的运算。
<br>
3.1.2  对数时间---O(log n):
<br>
```python
def logarithmic(n):
  result = 0
  while n > 1:
    n //= 2
    result += 1
  return result
```
&emsp;n的值会在每次循环遍历时被平分。如果n = 2x那么log n = x。这个程序执行的时间取决于输入的数据大小。
<br>
